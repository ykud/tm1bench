#region Prolog

sTargetCube = 'tm1bench Sales';

logoutput('info','Loading data in ' | NumberTostring(pNumberOfThreads) | ' threads, ' | NumberTostring(pNumSalesCells \ pNumberOfThreads) | ' rows per thread');
nCheckEvery = 5;
# Maximum wait time for this process
# let's assume the worst case of writing 10k records per second
nMaxWaitSeconds =  Int(pNumSalesCells \ pNumberOfThreads * 10000 );
if (pDisableLogging@='Y');
    if (CubeExists('}CubeProperties')=1);
        CellPutS('YES','}CubeProperties', sTargetCube, 'LOGGING' );
        RunProcess( 'tm1bench Set cube logging',
        	'pCube', sTargetCube,
        	'pLogging', 'NO' );
        Sleep(nCheckEvery*1000);
    endif;
endif;

RunProcess( 'tm1bench Cube clear data',
	'pCube', sTargetCube );
# sleep is crude, but I want to avoid flag files for everyoperation
Sleep(nCheckEvery*1000);

sUniqueIndex = NumberToString(Int(RAND * 100000));

# not clearing out data as it'll be a locking operation

i = 1;
while (i<=pNumberOfThreads);
    sSalesFile = 'tm1bench_sales_data_'|NumberToString( i ) |'_'|sUniqueIndex|'.csv';
    ExecuteProcess('tm1bench Sales generate test data',
	'pNumSalesCells', int(pNumSalesCells \ pNumberOfThreads),
	'pSalesFile', sSalesFile );
    i = i + 1;
end;
# Run loads in parallel
i = 1;
while (i<=pNumberOfThreads);
    sSalesFile = 'tm1bench_sales_data_'|NumberToString( i ) |'_'|sUniqueIndex|'.csv';
    sFlagFile = 'tm1bench_sales_data_'|NumberToString( i ) |'_'|sUniqueIndex|'_complete.csv';
    RunProcess( 'tm1bench Sales load data','pSourceFile', sSalesFile,'pFlagFile',sFlagFile);
    i = i + 1;
end;

# and let's wait for it complete

bCheck = 1;
nElapsedTime = 0;
while (bCheck=1);
    Sleep(nCheckEvery*1000);
    bCheck = 0;
    while (i<=pNumberOfThreads);
        sFlagFile = 'tm1bench_sales_data_'|NumberToString( i ) |'_'|sUniqueIndex|'_complete.csv';
        if (FileExists( sFlagFile )=0);
            bCheck = 1;
        endif;
        i = i + 1;
    end;
    nElapsedTime = nElapsedTime + nCheckEvery;
    if (nElapsedTime>=nMaxWaitSeconds);
        LogOutput( 'error', 'Waiting for over ' | NUmberToString(nElapsedTime) | ' seconds, something is broken' );
        bCheck = 0;
        ProcessError();
    endif;
end;
# need to wait for commit before we can remove the source files - let's hope we committ 100k cells a second
Sleep( Int(pNumSalesCells \ 100000 )*1000);    
i = 1;
while (i<=pNumberOfThreads);
    sSalesFile = 'tm1bench_sales_data_'|NumberToString( i ) |'_'|sUniqueIndex|'.csv';
    sFlagFile = 'tm1bench_sales_data_'|NumberToString( i ) |'_'|sUniqueIndex|'_complete.csv';
    ASCIIDelete( sSalesFile );
    ASCIIDelete( sFlagFile );
    i = i + 1;
end;

if (pDisableLogging@='Y');
    if (CubeExists('}CubeProperties')=1);
         RunProcess( 'tm1bench Set cube logging',
        	'pCube', sTargetCube,
        	'pLogging', 'YES' );
        Sleep(nCheckEvery*1000);
    else;
        logoutput('info','No }CubeProperties cube, must be on V12');
    endif;
endif;

#endregion